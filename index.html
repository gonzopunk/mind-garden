<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mind Garden â€” v12 (weather)</title>
<style>
  :root{
    --card:#fff; --ink:#0f172a; --muted:#64748b;
    --sky1:#cfeafe; --sky2:#a5d8ff; --ring:#fcd34d; --blue50:#eff6ff;
    --win-h: 460px;
    --ground-h: 140px;
    --sill-h: 40px;
    --grass:#16624f;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif; background:linear-gradient(#ecfdf5,#d1fae5); color:var(--ink)}
  .container{max-width:1100px; margin:0 auto; padding:24px}
  h1{margin:0 0 16px; font-weight:650; letter-spacing:-.02em}
  .grid{display:grid; gap:16px}
  .card{background:var(--card); border:1px solid #e5e7eb; border-radius:16px; box-shadow:0 2px 6px rgba(15,23,42,.06)}
  .content{padding:16px}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .btn{appearance:none; border:1px solid #d1d5db; background:#fff; color:#111827; border-radius:12px; padding:10px 14px; cursor:pointer; font-weight:600}
  .btn:hover{background:#f9fafb}
  .btn.primary{background:#10b981; color:#fff; border-color:#059669}
  .btn.secondary{background:#f3f4f6}
  .btn[disabled]{opacity:.5; cursor:not-allowed}
  .small{font-size:12px; color:var(--muted)}
  .tag{font-size:12px; background:#eef2ff; color:#4338ca; padding:3px 8px; border-radius:999px; display:inline-block}
  .input, select{width:100%; padding:10px 12px; border-radius:12px; border:1px solid #d1d5db; background:#fff}
  .status-grid{display:grid; grid-template-columns:repeat(6,minmax(0,1fr)); gap:16px}
  .status-item .label{font-size:12px; color:var(--muted)}
    .status-item .value{font-weight:600}
    .plants-grid{display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:16px}
  @media(max-width:700px){ .plants-grid{grid-template-columns:1fr} }
  .progress{position:relative; height:8px; background:#eef2ff; border-radius:999px; overflow:hidden}
  .progress .bar{height:100%; background:#34d399}
  /* window environment */
  .window{position:relative; border-radius:16px; overflow:hidden; box-shadow: inset 0 2px 6px rgba(0,0,0,.06); height:var(--win-h)}
  .sky{position:absolute; inset:0; background:linear-gradient(var(--sky1), var(--sky2)); z-index:0; transition: background .5s linear}
  .stars{position:absolute; inset:0; z-index:1; pointer-events:none; opacity:0; transition:opacity .5s linear}
  .ground{position:absolute; left:0; right:0; bottom:0; height:var(--ground-h); background:var(--grass); z-index:3}
  .mullion-h{position:absolute; left:0; right:0; top:50%; height:1px; background:rgba(255,255,255,.7); z-index:5}
  .mullion-v{position:absolute; top:0; bottom:0; left:50%; width:1px; background:rgba(255,255,255,.7); z-index:5}
  .frame{position:absolute; inset:0; pointer-events:none; box-shadow:inset 0 0 0 8px var(--ring); border-radius:16px; z-index:6}
  .sill{position:absolute; left:0; right:0; height:var(--sill-h); bottom:0; background:#fbbf24; box-shadow:0 2px 6px rgba(0,0,0,.1); z-index:6}
  .window-inner{position:relative; z-index:4; height:100%}
  .sun,.moon{position:absolute; width:64px; height:64px; border-radius:999px; transform:translate(-50%, -50%); z-index:1}
  .sun{background:#fde047; opacity:.9}
  .moon{background:#e2e8f0; opacity:0; box-shadow:0 0 8px rgba(255,255,255,.35) inset; overflow:hidden}
  .moon-shadow{position:absolute; top:0; left:0; width:100%; height:100%; background:#1e293b; border-radius:999px; transform-origin:center; transition:transform 0.3s ease}
  .cloud-band{position:absolute; left:0; right:0; display:flex; justify-content:space-around; z-index:2}
  .cloud{position:relative; opacity:.9; transition:opacity .5s linear}
  .cloud .b{position:absolute; background:#fff; border-radius:999px; box-shadow:0 2px 8px rgba(0,0,0,.06)}
  @keyframes cloudRL1{0%{transform:translateX(12%)}100%{transform:translateX(-12%)}}
  @keyframes cloudRL2{0%{transform:translateX(8%)}100%{transform:translateX(-16%)}}
  /* gallery absolute layer (above sill) */
  .gallery-layer{position:absolute; left:3%; right:3%; bottom: 0; top: 12%; z-index:7; pointer-events:none}
  .drag-plant{position:absolute; /* no translateX now */ display:flex; align-items:flex-end; justify-content:center; height: 40%; pointer-events:none; bottom: calc(var(--sill-h)/2);}
  .drag-plant.is-arrange{pointer-events:auto; cursor:grab}
  .drag-plant.is-arrange.dragging{cursor:grabbing}
  .mini-card .scaled{transform:scale(1.2); transform-origin:bottom center}
  /* sign (tip) */
  .sign{position:relative; background:#fff8e7; border:3px solid #d6aa6a; border-radius:12px; padding:12px 14px; font-family: "Georgia","Garamond",serif; color:#5b4636; box-shadow:0 3px 0 #c79a59, 0 8px 16px rgba(0,0,0,.06)}
  .sign:before,.sign:after{content:""; position:absolute; top:-8px; width:8px; height:8px; background:#c79a6a; border-radius:50%}
  .sign:before{left:12px} .sign:after{right:12px}
  .sign .title{font-weight:700; font-size:14px; margin-bottom:6px}
  .sign p{margin:0; font-size:14px; line-height:1.35}
  .small-note{font-size:12px; color:var(--muted)}
  .hidden{display:none !important}
  /* curtains */
  .curtain-wrap{position:absolute; inset:0; pointer-events:none; z-index:6}
  .curtain-svg{position:absolute; top:0; bottom:0; width:56px; filter:drop-shadow(0 2px 4px rgba(0,0,0,.08))}
  .curtain-svg.left{left:0}
  .curtain-svg.right{right:0; transform:scaleX(-1)}
  .valance-svg{position:absolute; left:0; right:0; top:0; height:44px; width:100%; filter:drop-shadow(0 2px 4px rgba(0,0,0,.08))}
  /* windowsill navigation */
  .sill-nav{position:absolute; top:50%; transform:translateY(-50%); z-index:8; background:rgba(255,255,255,.9); border:1px solid #e5e7eb; border-radius:50%; width:40px; height:40px; display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,.1)}
  .sill-nav:hover{background:#fff}
  .sill-nav.left{left:8px}
  .sill-nav.right{right:8px}
  .sill-dots{position:absolute; bottom:52px; left:50%; transform:translateX(-50%); z-index:8; display:flex; gap:8px}
  .sill-dot{width:8px; height:8px; border-radius:50%; background:rgba(255,255,255,.5); border:1px solid rgba(0,0,0,.1); cursor:pointer}
  .sill-dot.active{background:#10b981}
  /* weather effects */
  .weather-layer{position:absolute; inset:0; z-index:2; pointer-events:none; overflow:hidden}
  .rain-drop{position:absolute; width:1px; height:12px; background:linear-gradient(transparent, rgba(174,194,224,0.6)); animation:rain-fall linear infinite}
  @keyframes rain-fall{0%{transform:translateY(-20px)}100%{transform:translateY(calc(var(--win-h) + 20px))}}
  .snow-flake{position:absolute; width:4px; height:4px; background:white; border-radius:50%; opacity:0.8; animation:snow-fall linear infinite}
  @keyframes snow-fall{0%{transform:translateY(-10px) translateX(0)}100%{transform:translateY(calc(var(--win-h) + 10px)) translateX(20px)}}
  .thermometer{position:absolute; top:12px; right:12px; z-index:8; background:rgba(255,255,255,0.9); border:2px solid #94a3b8; border-radius:12px; padding:8px 6px; box-shadow:0 2px 4px rgba(0,0,0,.08); width:32px}
  .thermo-tube{position:relative; width:8px; height:100px; background:#e5e7eb; border-radius:4px; margin:0 auto 6px}
  .thermo-mercury{position:absolute; bottom:0; left:0; right:0; background:#ef4444; border-radius:4px; transition:height 0.5s ease}
  .thermo-bulb{width:16px; height:16px; background:#ef4444; border-radius:50%; margin:0 auto; position:relative; top:-2px}
  .thermo-temp{font-size:11px; font-weight:600; text-align:center; margin-top:4px; color:#0f172a}
</style>
</head>
<body>
<div class="container" id="app"></div>

<!-- SunCalc for sunrise/sunset + moon calculations -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>

<script>
(function(){
  const SUNRISE_H = 7, SUNSET_H = 19; // single-plant mode
  const FALLBACK_LOC = { lat:41.8781, lon:-87.6298 }; // Chicago fallback
  const WEATHER_CACHE_MS = 15 * 60 * 1000; // 15 minutes
  
  // Open-Meteo weather code mapping
  const WEATHER_CODES = {
    0: 'clear', 1: 'clear', 2: 'partly-cloudy', 3: 'cloudy',
    45: 'fog', 48: 'fog',
    51: 'drizzle', 53: 'drizzle', 55: 'drizzle',
    61: 'rain', 63: 'rain', 65: 'rain', 66: 'rain', 67: 'rain',
    71: 'snow', 73: 'snow', 75: 'snow', 77: 'snow', 85: 'snow', 86: 'snow',
    80: 'rain', 81: 'rain', 82: 'rain',
    95: 'thunderstorm', 96: 'thunderstorm', 99: 'thunderstorm'
  };
  
  const fmt2 = (n)=> String(n).padStart(2,'0');
  const toAmPm = (h,m)=>{ const period = h>=12 ? "p.m." : "a.m."; const hh = h%12===0? 12 : h%12; return hh+":"+fmt2(m)+" "+period; };
  // Use local time instead of UTC so daily resets align with the user's timezone
  const todayKey = ()=>{
    const d = new Date();
    return `${d.getFullYear()}-${fmt2(d.getMonth()+1)}-${fmt2(d.getDate())}`;
  };
  const clamp = (v,lo,hi)=> Math.min(hi, Math.max(lo,v));

  const DEFAULT_CONFIG = {
    dailyUnlockHour: 7, dailyUnlockMinute: 0,
    dailyActions: 30,
    actionsToMature: 20,
    breathingEnabled: true,
    turnsBetweenBreaths: 5,
    breathPhases: [4,7,8],
    unlockTimeText: "7:00 a.m.",
    postActionPauseEnabled: true,
    postActionPauseSec: 3
  };
  const LS_KEY = "mind-garden-v10-12";

  const STYLE_COLORS = { daisy:["white","yellow"], sunflower:["yellow"], tulip:["red","pink","yellow","white"], lotus:["pink","white"], bell:["blue","purple"] };
  const COLOR_HEX = { white:"#ffffff", yellow:"#facc15", pink:"#f472b6", blue:"#60a5fa", purple:"#a78bfa", red:"#ef4444" };
  const POT_STYLES = ["terracotta","striped","ceramic","classic"];
  const TYPE_HEIGHT = { daisy:0.42, sunflower:0.50, tulip:0.36, lotus:0.46, bell:0.40 };
  const HEIGHT_STEPS = [0, 0.12, 0.24];
  
  const WINDOWSILL_THEMES = [
    { name: "Classic Wood", sillColor: "#fbbf24", frameColor: "#fcd34d", bgTint: "rgba(251, 191, 36, 0.05)" },
    { name: "White Paint", sillColor: "#f8fafc", frameColor: "#e2e8f0", bgTint: "rgba(248, 250, 252, 0.05)" },
    { name: "Dark Walnut", sillColor: "#78350f", frameColor: "#92400e", bgTint: "rgba(120, 53, 15, 0.05)" },
    { name: "Stone Grey", sillColor: "#64748b", frameColor: "#94a3b8", bgTint: "rgba(100, 116, 139, 0.05)" },
    { name: "Sage Green", sillColor: "#84cc16", frameColor: "#a3e635", bgTint: "rgba(132, 204, 22, 0.05)" }
  ];

  const DOPAMINE_FACTS = [
    "Unpredictable rewards keep prediction errors high; predictability reduces compulsive checking.",
    "Delaying actions slightly can weaken cueâ†’reward linkage and curb habits.",
    "Consistent sleep, sunlight, and exercise stabilize baseline dopamine tone.",
    "Slow, deep breathing shifts the nervous system toward parasympathetic calm.",
    "Small, steady progress often outperforms rare, large rewards for long-term habits.",
    "Batching notifications lowers the number of reinforcement cycles per day.",
    "Ending sessions cleanly helps prevent 'just one more' loops.",
    "Warm starts beat heroic sprints: two easy actions now beat a perfect plan later.",
    "Label the habit loop out loudâ€”naming it reduces its pull.",
    "Make success visible but calm: steady growth, not fireworks.",
    "Protect morningsâ€”early checks can hijack the day's reward budget.",
    "Track effort, not perfectionâ€”missed days are potholes, not cliffs.",
    "Nourish basics first; brains are living gardens.",
    "Your brain notices change, not samenessâ€”keep tools boring, goals clear.",
    "Cravings fade like waves; ride one breath at a time.",
    "Reduce cues, reduce cravings: hide the slot machine, find the book.",
    "Sleep is the master reset for learning and mood.",
    "Move your body dailyâ€”motion fertilizes attention and memory.",
    "Swap 'doom scroll' with 'single scroll': open one page, one purpose.",
    "Short, timed bouts of focus train dopamine to expect closure.",
    "Write wins downâ€”visible progress nudges the next step.",
    "If it's urgent, it can wait one breath. If it can't, call.",
    "Savoring small wins builds resilience more reliably than big highs.",
    "Practice quitting on time: ends teach your brain that stopping is safe.",
    "Make friction your friendâ€”extra steps reduce compulsive checking.",
    "Pair a cue with a calm act: one stretch, one breath, then choose.",
    "Schedule fun on purpose so it doesn't leak into everything else.",
    "Learning sticks when effort is spaced and sleep follows.",
    "Environment beats willpower: rearrange the room, change the loop.",
    "When stuck, lower the barâ€”do the smallest true next step.",
    "Treat attention like sunlight: point it where you want things to grow.",
  ];

  function DEFAULT_PLANT(){
    const style = "daisy"; const colors = STYLE_COLORS[style];
    return { growth:0, flowerStyle:style, flowerColor:colors[0], potStyle: POT_STYLES[Math.floor(Math.random()*POT_STYLES.length)],
      styleLocked:false, readyToPlace:false, lowerLeafLeft: Math.random()<0.5, bellDir: (Math.random()<0.5?-1:1),
      leaf1Y:88+Math.round(Math.random()*6), leaf2Y:72+Math.round(Math.random()*6) };
  }

  let state = (function(){
    try{
      const s = JSON.parse(localStorage.getItem(LS_KEY)||"null");
      if (!s) return fresh();
      const today = todayKey();
      if (!s.day || s.day.date!==today){
        s.day = { date: today, actionsRemaining: (s.config?.dailyActions||DEFAULT_CONFIG.dailyActions), plants: s.day?.plants || [DEFAULT_PLANT()], playedToday:false };
      }
      
      // Migrate old gallery to windowsills structure
      if (s.gallery && !s.windowsills) {
        const themeIndex = 0;
        s.windowsills = [{
          id: 0,
          theme: themeIndex,
          plants: s.gallery.map((gp,i,arr)=> {
            let base = (TYPE_HEIGHT[gp.flowerStyle||'daisy']||0.42);
            let tier = (gp.heightTier!=null? gp.heightTier : Math.floor(Math.random()*HEIGHT_STEPS.length));
            let h = base + HEIGHT_STEPS[tier];
            if (gp.galleryH!=null) h = gp.galleryH;
            return { xPct: (gp.xPct!=null? gp.xPct : ( (i+1)/(arr.length+1) * 94 + 3 ) ), galleryH: Math.max(0.34, Math.min(0.62, h)), heightTier: tier, ...gp };
          }),
          unlockedAt: s.streak || 0
        }];
        delete s.gallery;
      }
      
      if (!s.windowsills) s.windowsills = [{ id: 0, theme: 0, plants: [], unlockedAt: 0 }];
      if (s.currentSillIndex == null) s.currentSillIndex = 0;
      
      // Ensure windowsills data is valid
      s.windowsills = s.windowsills.map(sill => ({
        ...sill,
        plants: (sill.plants || []).map((gp,i,arr)=> {
          let base = (TYPE_HEIGHT[gp.flowerStyle||'daisy']||0.42);
          let tier = (gp.heightTier!=null? gp.heightTier : Math.floor(Math.random()*HEIGHT_STEPS.length));
          let h = base + HEIGHT_STEPS[tier];
          if (gp.galleryH!=null) h = gp.galleryH;
          return { xPct: (gp.xPct!=null? gp.xPct : ( (i+1)/(arr.length+1) * 94 + 3 ) ), galleryH: Math.max(0.34, Math.min(0.62, h)), heightTier: tier, ...gp };
        })
      }));
      
      s.day.plants = (s.day.plants||[]).map(p=> ({ lowerLeafLeft: (p.lowerLeafLeft!=null?p.lowerLeafLeft:(Math.random()<0.5)), bellDir:(p.bellDir!=null?p.bellDir:(Math.random()<0.5?-1:1)), ...p }));
      if (s.day.plants.length>1){
        const [first,...rest] = s.day.plants;
        s.day.plants = [first];
        // Single-plant mode: move completed extras to current windowsill
        rest.forEach(p=>{
          if ((p.growth||0)>=100){
            const currentSill = s.windowsills[s.currentSillIndex];
            const base = TYPE_HEIGHT[p.flowerStyle||'daisy']||0.42;
            const tier = Math.floor(Math.random()*HEIGHT_STEPS.length);
            const h = Math.max(0.34, Math.min(0.62, base + HEIGHT_STEPS[tier]));
            const index = currentSill.plants.length;
            const xPct = (currentSill.plants.length===0)? 50 : Math.max(3, Math.min(97, ( (index+1)/(currentSill.plants.length+1) * 94 + 3 )));
            currentSill.plants.splice(index,0,{...p, galleryH:h, heightTier:tier, xPct});
          }
        });
      }
      if (s.day.plants.length===0) s.day.plants=[DEFAULT_PLANT()];
      if (!s.config) s.config = {...DEFAULT_CONFIG};
      if (!('actionsToMature' in s.config)) s.config.actionsToMature = 20;
      if (!('postActionPauseEnabled' in s.config)) s.config.postActionPauseEnabled = true;
      if (!('postActionPauseSec' in s.config)) s.config.postActionPauseSec = 3;
      if (!s.location) s.location = { geoEnabled:false, coords:null, denied:false };
      if (!s.weather) s.weather = { enabled:false, data:null, lastFetch:0, tempUnit:'auto' };
      if (!('devTimeOverride' in s)) s.devTimeOverride = false;
      s.sessionActive=false; s.cooldownUntil=0; s.breathPrepUntil=0; s.postPauseUntil=0; s.actionCount=0; s.lastFact=''; s.arrangeMode=false;
      s.unlimitedActions=false; s.devMode=false; s.devSliderHour=13.0;
      s.__ppActive=false;
      s.movingPlantIndex=null; // Track which plant is being moved
      delete s.plantSlots; // single-plant mode: no slots
      delete s.pendingPlantUnlock; // remove streak unlock flag
      delete s.gallery; // remove old gallery structure
      return s;
    }catch{ return fresh(); }
  })();

  function fresh(){
    return { config:{...DEFAULT_CONFIG}, day:{ date: todayKey(), actionsRemaining: DEFAULT_CONFIG.dailyActions, plants: [DEFAULT_PLANT()], playedToday:false },
      streak:0, lastPlayDate:null, windowsills: [{ id: 0, theme: 0, plants: [], unlockedAt: 0 }], currentSillIndex: 0,
      sessionActive:false, cooldownUntil:0, breathPrepUntil:0, postPauseUntil:0, actionCount:0, lastFact:'',
      arrangeMode:false, unlimitedActions:false, devMode:false, devSliderHour:13.0, devTimeOverride:false, __ppActive:false,
      movingPlantIndex:null, location:{ geoEnabled:false, coords:null, denied:false },
      weather:{ enabled:false, data:null, lastFetch:0, tempUnit:'auto' } };
  }
  function save(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
  
  function getTotalPlantCount(){
    return state.windowsills.reduce((sum, sill) => sum + sill.plants.length, 0);
  }
  
  function checkAndUnlockWindowsills(){
    const totalPlants = getTotalPlantCount();
    const neededSills = Math.floor(totalPlants / 5) + 1;
    while (state.windowsills.length < neededSills) {
      const newId = state.windowsills.length;
      const themeIndex = newId % WINDOWSILL_THEMES.length;
      state.windowsills.push({
        id: newId,
        theme: themeIndex,
        plants: [],
        unlockedAt: totalPlants
      });
    }
  }

  function markPlayed(){
    if (state.day.playedToday) return;
    const last = state.lastPlayDate, today = state.day.date;
    const y = new Date(); y.setDate(y.getDate()-1); const yesterdayKey = y.toISOString().slice(0,10);
    const newStreak = last===yesterdayKey ? (state.streak+1) : (last===today ? state.streak : (last ? 1 : 1));
    state.day.playedToday = true; state.streak = newStreak; state.lastPlayDate = today;
  }

  function parseUnlockTime(){
    const s = state.config.unlockTimeText || "7:00 a.m.";
    const m1 = s.match(/^(\d{1,2}):(\d{2})\s*([ap])?\\.?m?\\.?$/i);
    if (m1){ let h=+m1[1], m=+m1[2], ap=m1[3]; if (ap){ ap=ap.toLowerCase(); if (ap==='p'&&h!==12) h+=12; if (ap==='a'&&h===12) h=0; } return {h, m}; }
    const m2 = s.match(/^(\d{1,2}):(\d{2})$/); if (m2){ return {h:+m2[1], m:+m2[2]}; } return {h:7, m:0};
  }
  function isLocked(){ const {h,m}=parseUnlockTime(); const d=new Date(); d.setHours(h,m,0,0); return new Date() < d; }
  function nextUnlock(){ const {h,m}=parseUnlockTime(); const now=new Date(); const d=new Date(); d.setHours(h,m,0,0); if (now>d) d.setDate(d.getDate()+1); return d; }
  function startSession(){ if (isLocked()) return; if (state.day.actionsRemaining<=0 && !state.unlimitedActions) return; state.sessionActive=true; save(); render(); }
  function endSession(){ state.sessionActive=false; markPlayed(); save(); render(); }

  function maybeBreathe(){
    const should = state.config.breathingEnabled && ((state.actionCount) % state.config.turnsBetweenBreaths === 0);
    if (!should) return;
    const prep = 3000; const phasesMs = state.config.breathPhases.reduce((a,b)=>a+b,0)*1000; const now = Date.now();
    state.breathPrepUntil = now + prep; state.cooldownUntil = 0;
    setTimeout(()=>{ state.breathPrepUntil=0; state.cooldownUntil=Date.now()+phasesMs; save(); renderBreathingOnly(); }, prep);
    save(); renderBreathingOnly();
  }
  function afterAnyAction(){
    markPlayed();
    state.actionCount += 1;
    state.lastFact = DOPAMINE_FACTS[Math.floor(Math.random()*DOPAMINE_FACTS.length)];
    const willBreathe = state.config.breathingEnabled && ((state.actionCount) % state.config.turnsBetweenBreaths === 0);
    if (!willBreathe && state.config.postActionPauseEnabled){
      const pauseMs = Math.max(0, (state.config.postActionPauseSec||0) * 1000);
      state.postPauseUntil = Date.now() + pauseMs;
      state.__ppActive = true;
    }
    maybeBreathe();
    save(); render();
  }
  function gainPerAction(){ return 100 / Math.max(1, state.config.actionsToMature); }
  function decActions(){ if (!state.unlimitedActions) state.day.actionsRemaining -= 1; }
  function tend(idx){
    const now = Date.now();
    if (!state.sessionActive) return;
    if ((state.day.actionsRemaining<=0 && !state.unlimitedActions)) { endSession(); return; }
    if (now<state.cooldownUntil || now<state.postPauseUntil) return;
    decActions();
    const gain = gainPerAction();
    state.day.plants = state.day.plants.map((p,i)=>{
      if (i!==idx) return p;
      const newGrowth = Math.min(100, p.growth + gain); const justCompleted = (p.growth<100 && newGrowth>=100);
      return {...p, growth:newGrowth, readyToPlace: justCompleted ? true : p.readyToPlace };
    });
    afterAnyAction();
  }
  
  function placePlantFromIndex(i, sillIndex){
    const p = state.day.plants[i]; 
    if (!p || !p.readyToPlace) return;
    insertIntoSill(p, sillIndex);
    state.day.plants[i] = DEFAULT_PLANT();
    checkAndUnlockWindowsills();
    save(); render();
  }
  
  function insertIntoSill(plant, sillIndex){
    const sill = state.windowsills[sillIndex];
    if (!sill) return;
    const base = TYPE_HEIGHT[plant.flowerStyle] || 0.42;
    const tier = Math.floor(Math.random()*HEIGHT_STEPS.length);
    const h = Math.max(0.34, Math.min(0.62, base + HEIGHT_STEPS[tier]));
    const xPct = (sill.plants.length===0)? 50 : Math.max(3, Math.min(97, ( (sill.plants.length+1)/(sill.plants.length+1) * 94 + 3 )));
    sill.plants.push({...plant, galleryH: h, heightTier: tier, xPct});
  }
  
  function movePlantBetweenSills(fromSillIndex, plantIndex, toSillIndex){
    if (fromSillIndex === toSillIndex) return;
    const fromSill = state.windowsills[fromSillIndex];
    const toSill = state.windowsills[toSillIndex];
    if (!fromSill || !toSill || plantIndex < 0 || plantIndex >= fromSill.plants.length) return;
    
    const plant = fromSill.plants[plantIndex];
    fromSill.plants.splice(plantIndex, 1);
    
    const xPct = (toSill.plants.length===0)? 50 : Math.max(3, Math.min(97, ( (toSill.plants.length+1)/(toSill.plants.length+1) * 94 + 3 )));
    toSill.plants.push({...plant, xPct});
    
    state.movingPlantIndex = null;
    save(); render();
  }

  function progressBar(v){ return `<div class="progress"><span class="bar" style="width:${Math.max(0, Math.min(100, v))}%"></span></div>`; }

  /* --- SVG helpers & plant renderers --- */
  function teardropPath(cx, cy, w, h){
    const x0 = cx, y0 = cy;
    const lx = cx - w/2, rx = cx + w/2, ty = cy - h;
    return `M ${x0} ${y0} C ${lx} ${cy - h*0.55}, ${lx} ${ty}, ${cx} ${ty} C ${rx} ${ty}, ${rx} ${cy - h*0.55}, ${x0} ${y0} Z`;
  }
  function rotatePath(path, cx, cy, deg){ return `<g transform="rotate(${deg} ${cx} ${cy})">${path}</g>`; }

  function potSVG(style){
    if (style==="striped"){ return `<g><ellipse cx="60" cy="126" rx="22" ry="4" fill="rgba(0,0,0,0.08)"/><path d="M36 100 L84 100 L76 126 Q60 132 44 126 Z" fill="#f4a261" stroke="#e38b3a"/><rect x="32" y="96" width="56" height="10" rx="6" fill="#f6ad55" stroke="#e38b3a"/><rect x="36" y="108" width="48" height="4" rx="2" fill="#e9c46a"/><rect x="36" y="116" width="48" height="4" rx="2" fill="#e9c46a"/></g>`; }
    if (style==="ceramic"){ return `<g><ellipse cx="60" cy="126" rx="22" ry="4" fill="rgba(0,0,0,0.08)"/><path d="M36 100 L84 100 L76 126 Q60 132 44 126 Z" fill="#fef3c7" stroke="#fcd34d"/><rect x="32" y="96" width="56" height="10" rx="6" fill="#fde68a" stroke="#fcd34d"/><circle cx="46" cy="112" r="3" fill="#60a5fa"/><circle cx="60" cy="118" r="3" fill="#34d399"/><circle cx="74" cy="111" r="3" fill="#f472b6"/></g>`; }
    if (style==="classic"){ return `<g><ellipse cx="60" cy="126" rx="22" ry="4" fill="rgba(0,0,0,0.08)"/><path d="M36 100 L84 100 L76 126 Q60 132 44 126 Z" fill="#e07a5f" stroke="#c4664e"/><rect x="32" y="96" width="56" height="10" rx="6" fill="#ed8f6a" stroke="#c4664e"/><path d="M38 110 Q60 104 82 110" fill="none" stroke="rgba(255,255,255,.35)" stroke-width="2"/></g>`; }
    return `<g><ellipse cx="60" cy="126" rx="22" ry="4" fill="rgba(0,0,0,0.08)"/><path d="M36 100 L84 100 L76 126 Q60 132 44 126 Z" fill="#f4a261" stroke="#e38b3a"/><rect x="32" y="96" width="56" height="10" rx="6" fill="#f6ad55" stroke="#e38b3a"/><rect x="40" y="111" width="40" height="4" rx="2" fill="#e9c46a"/></g>`;
  }

  function plantSVG(p){
    const growth = p.growth||0; const stemH = 10 + growth*0.8; const baseX = 60, topX=60, topY = 100 - stemH;
    let stemPath = `<path d="M ${baseX} 100 Q ${baseX} ${100 - stemH*0.4}, ${topX} ${topY}" stroke="#047857" stroke-width="2" fill="none" />`;

    function petals(style){
      const col = COLOR_HEX[p.flowerColor] || "#f472b6";
      if (style==="daisy"){
        let petals=''; const petalColor = (p.flowerColor==="white") ? "#ffffff" : COLOR_HEX["yellow"];
        for(let i=0;i<12;i++){ const ang=i*Math.PI/6, px=topX+Math.cos(ang)*10, py=topY+Math.sin(ang)*10;
          petals += `<ellipse cx="${px}" cy="${py}" rx="5" ry="9" transform="rotate(${ang*180/Math.PI} ${px} ${py})" fill="${petalColor}" stroke="rgba(0,0,0,.06)" stroke-width=".5"/>`; }
        return `${petals}<circle cx="${topX}" cy="${topY}" r="5.5" fill="#d97706"/>`;
      }
      if (style==="tulip"){
        return `<path d="M ${topX-10} ${topY} C ${topX-18} ${topY+18}, ${topX+18} ${topY+18}, ${topX+10} ${topY} Q ${topX+2} ${topY-22}, ${topX} ${topY-10} Q ${topX-2} ${topY-22}, ${topX-10} ${topY} Z" fill="${col}" stroke="rgba(0,0,0,.06)" stroke-width=".6"/>`;
      }
      if (style==="sunflower"){
        let petals=''; for(let i=0;i<22;i++){ const ang=i*Math.PI/11, px=topX+Math.cos(ang)*12, py=topY+Math.sin(ang)*12;
          petals += `<ellipse cx="${px}" cy="${py}" rx="4.5" ry="8" transform="rotate(${ang*180/Math.PI} ${px} ${py})" fill="${COLOR_HEX["yellow"]}"/>`; }
        return `${petals}<circle cx="${topX}" cy="${topY}" r="7.5" fill="#8b5e34"/>`;
      }
      if (style==="lotus"){
        const petCol=(p.flowerColor==="white"?"#ffffff":COLOR_HEX["pink"]);
        let g='';
        const back1 = teardropPath(topX-12, topY+10, 26, 30);
        const back2 = teardropPath(topX+12, topY+10, 26, 30);
        g += `<path d="${back1}" fill="${petCol}" opacity="0.55" />`;
        g += `<path d="${back2}" fill="${petCol}" opacity="0.55" />`;
        const sideL = teardropPath(topX-11, topY+8, 22, 36);
        const sideR = teardropPath(topX+11, topY+8, 22, 36);
        g += `<path d="${sideL}" fill="${petCol}" opacity="0.85" />`;
        g += `<path d="${sideR}" fill="${petCol}" opacity="0.85" />`;
        const center = teardropPath(topX, topY+6, 20, 42);
        g += `<path d="${center}" fill="${petCol}" opacity="0.98" />`;
        return g;
      }
      if (style==="bell"){
        const bellCol=(p.flowerColor==="blue"?COLOR_HEX["blue"]:COLOR_HEX["purple"]);
        const dir = (p.bellDir||1);
        const neckX = topX + dir*10, neckY = topY + 2;
        const peduncle = `<path d="M ${topX} ${topY} Q ${topX + dir*8} ${topY+6}, ${neckX} ${neckY}" stroke="#047857" stroke-width="2" fill="none" />`;
        const baseX = neckX + dir*2, baseY = neckY + 6;
        let lobes='';
        const lobeAngles = [-22,-8,8,22];
        lobeAngles.forEach(a=>{
          const path = teardropPath(baseX, baseY+14, 16, 30);
          lobes += rotatePath(`<path d="${path}" fill="${bellCol}" opacity="0.9" stroke="rgba(0,0,0,.08)" stroke-width="0.6"/>`, baseX, baseY+14, a);
        });
        const rim = `<ellipse cx="${baseX}" cy="${baseY+4}" rx="14" ry="5" fill="${bellCol}" opacity="0.9"/>`;
        return peduncle + rim + lobes;
      }
      return "";
    }
    const lowerLeft = !!p.lowerLeafLeft;
    const lowerY = p.leaf1Y, upperY = p.leaf2Y;
    const leftLeafPath = (y,color)=> `<path d="M60 ${y} C35 ${y-5}, 35 ${y-15}, 60 ${y-18}" fill="${color}"/>`;
    const rightLeafPath = (y,color)=> `<path d="M60 ${y} C85 ${y-5}, 85 ${y-15}, 60 ${y-18}" fill="${color}"/>`;
    const leafLower = lowerLeft ? leftLeafPath(lowerY,"#86efac") : rightLeafPath(lowerY,"#86efac");
    const leafUpper = lowerLeft ? rightLeafPath(upperY,"#22c55e") : leftLeafPath(upperY,"#22c55e");

    return `<svg viewBox="0 0 120 140" style="width:100%; height:144px; overflow:visible">
      ${potSVG(p.potStyle)}
      ${stemPath}
      ${growth>33? leafLower : ''}
      ${growth>66? leafUpper : ''}
      ${growth>=100? `<g>${petals(p.flowerStyle)}</g>` : ''}
    </svg>`;
  }

  function plantCard(p,i){
    const now = Date.now();
    const postLeft = Math.max(0, Math.ceil((state.postPauseUntil - now)/1000));
    const inPostPause = now < state.postPauseUntil;
    const canAct = state.sessionActive && (state.day.actionsRemaining>0 || state.unlimitedActions) && now>=state.cooldownUntil && !inPostPause && (p.styleLocked || p.growth>0);
    const buttonLabel = inPostPause ? String(postLeft) : "Tend";
    
    const localPlace = p.readyToPlace ? `<div class="sign" style="margin-top:10px"><div class="title">ðŸŽ‰ Congratulations!</div><p>Your flower has reached maturity.</p><div style="margin-top:8px">${sillPicker(i)}</div></div>` : '';
    
    return `<div class="card" data-plant-index="${i}"><div class="content">
      <div class="small">Your plant</div>
      ${plantSVG(p)}
      ${progressBar(p.growth)}
      <div class="small">Growth: ${Math.round(p.growth)}%</div>
      ${(p.growth===0 && !p.styleLocked) ? `<div class="grid" style="grid-template-columns:1fr 1fr; gap:8px; margin-top:8px">
          <div><div class="small">Flower style</div><select data-action="set-style" data-index="${i}" class="input">
              ${["daisy","tulip","sunflower","lotus","bell"].map(st=> `<option value="${st}" ${p.flowerStyle===st?'selected':''}>${st[0].toUpperCase()+st.slice(1)}</option>`).join('')}
          </select></div>
          <div><div class="small">Color</div><select data-action="set-color" data-index="${i}" class="input">
              ${STYLE_COLORS[p.flowerStyle].map(c=> `<option value="${c}" ${p.flowerColor===c?'selected':''}>${c[0].toUpperCase()+c.slice(1)}</option>`).join('')}
          </select></div>
        </div>
        <div class="grid" style="grid-template-columns:1fr; gap:8px; margin-top:8px">
          <div><div class="small">Pot style</div><select data-action="set-pot" data-index="${i}" class="input">
              ${["terracotta","striped","ceramic","classic"].map(ps=> `<option value="${ps}" ${p.potStyle===ps?'selected':''}>${ps[0].toUpperCase()+ps.slice(1)}</option>`).join('')}
          </select></div>
        </div>
        <div class="row" style="margin-top:8px"><button class="btn secondary" data-action="lock-type" data-index="${i}">Start growing</button></div>`
        : `<div class="small" style="margin-top:8px">${p.readyToPlace ? 'Fully grown.' : 'Growing steadilyâ€¦'}</div>`}
      <div class="row" style="margin-top:10px"><button class="btn primary" data-action="tend" data-index="${i}" ${!canAct?'disabled':''}>${buttonLabel}</button></div>
      ${localPlace}
    </div></div>`;
  }
  
  function sillPicker(plantIndex){
    const totalPlants = getTotalPlantCount();
    const willUnlock = Math.floor((totalPlants + 1) / 5) > Math.floor(totalPlants / 5);
    return `<div>
      <div class="small" style="margin-bottom:8px">Choose a windowsill:</div>
      <div class="row" style="gap:8px">
        ${state.windowsills.map((sill, idx) => `
          <button class="btn ${idx === state.currentSillIndex ? 'primary' : 'secondary'}" 
                  data-action="place-on-sill" 
                  data-plant-index="${plantIndex}" 
                  data-sill-index="${idx}">
            ${WINDOWSILL_THEMES[sill.theme].name}
          </button>
        `).join('')}
      </div>
      ${willUnlock ? `<div class="small-note" style="margin-top:8px">âœ¨ This will unlock a new windowsill!</div>` : ''}
    </div>`;
  }

  function curtains(){ return `<div class="curtain-wrap">
      <svg class="curtain-svg left" viewBox="0 0 56 280" preserveAspectRatio="none">
        <path d="M0 0 L36 0 C28 20,46 40,36 60 C28 80,46 100,36 120 C28 140,46 160,36 180 C28 200,46 220,36 240 C28 260,46 280,36 300 L0 300 Z" fill="rgba(255,255,255,.7)"/>
        <path d="M0 0 L36 0 C30 20,44 40,36 60 C30 80,44 100,36 120 C30 140,44 160,36 180 C30 200,44 220,36 240 C30 260,44 280,36 300 L0 300 Z" fill="rgba(255,255,255,.55)"/>
      </svg>
      <svg class="curtain-svg right" viewBox="0 0 56 280" preserveAspectRatio="none">
        <path d="M0 0 L36 0 C28 20,46 40,36 60 C28 80,46 100,36 120 C28 140,46 160,36 180 C28 200,46 220,36 240 C28 260,46 280,36 300 L0 300 Z" fill="rgba(255,255,255,.7)"/>
        <path d="M0 0 L36 0 C30 20,44 40,36 60 C30 80,44 100,36 120 C30 140,44 160,36 180 C30 200,44 220,36 240 C30 260,44 280,36 300 L0 300 Z" fill="rgba(255,255,255,.55)"/>
      </svg>
      <svg class="valance-svg" viewBox="0 0 600 44" preserveAspectRatio="none">
        <path d="M0 0 H600 V24 C560 34,520 34,480 24 C440 14,400 14,360 24 C320 34,280 34,240 24 C200 14,160 14,120 24 C80 34,40 34,0 24 Z" fill="rgba(255,255,255,.75)"/>
        <path d="M0 0 H600 V20 C560 30,520 30,480 20 C440 10,400 10,360 20 C320 30,280 30,240 20 C200 10,160 10,120 20 C80 30,40 30,0 20 Z" fill="rgba(255,255,255,.6)"/>
      </svg></div>`; }

  function cloud(w){ return `<div class="cloud" style="width:${w}px; height:${w*0.5}px">
    <div class="b" style="left:10%;top:30%;width:40%;height:55%"></div>
    <div class="b" style="left:35%;top:15%;width:45%;height:70%"></div>
    <div class="b" style="left:55%;top:35%;width:30%;height:50%"></div>
    <div class="b" style="left:0%;top:40%;width:25%;height:45%"></div>
  </div>`; }

  function buildStars(n=90){
    const container = document.createElement('div'); container.className='stars';
    for(let i=0;i<n;i++){ const s=document.createElement('div'); const size=Math.random()<0.85?2:3; s.style.cssText=`position:absolute;width:${size}px;height:${size}px;border-radius:50%;background:rgba(255,255,255,.9);left:${Math.round(Math.random()*100)}%;top:${Math.round(Math.random()*70)}%`; container.appendChild(s); }
    return container;
  }
  
  function buildWeatherEffects(){
    if (!state.weather.enabled || !state.weather.data) return '';
    
    const condition = state.weather.data.condition;
    const container = document.createElement('div');
    container.className = 'weather-layer';
    
    if (condition === 'rain' || condition === 'drizzle' || condition === 'thunderstorm') {
      const dropCount = condition === 'drizzle' ? 30 : 50;
      for(let i=0; i<dropCount; i++){
        const drop = document.createElement('div');
        drop.className = 'rain-drop';
        drop.style.cssText = `left:${Math.random()*100}%;animation-duration:${0.5 + Math.random()*0.3}s;animation-delay:${Math.random()*2}s`;
        container.appendChild(drop);
      }
    } else if (condition === 'snow') {
      for(let i=0; i<40; i++){
        const flake = document.createElement('div');
        flake.className = 'snow-flake';
        flake.style.cssText = `left:${Math.random()*100}%;animation-duration:${3 + Math.random()*2}s;animation-delay:${Math.random()*3}s`;
        container.appendChild(flake);
      }
    }
    
    return container.outerHTML;
  }
  
  function getCloudConfig(){
    if (!state.weather.enabled || !state.weather.data) {
      return { count: 'normal', opacity: 0.9 }; // Default
    }
    
    const condition = state.weather.data.condition;
    const cloudCover = state.weather.data.cloudCover;
    
    if (condition === 'clear' && cloudCover < 10) {
      return { count: 'none', opacity: 0 };
    } else if (condition === 'clear' || condition === 'partly-cloudy') {
      return { count: 'light', opacity: 0.7 };
    } else if (condition === 'cloudy' || condition === 'fog') {
      return { count: 'heavy', opacity: 0.95 };
    } else if (condition === 'rain' || condition === 'drizzle' || condition === 'thunderstorm') {
      return { count: 'storm', opacity: 0.85, dark: true };
    } else if (condition === 'snow') {
      return { count: 'heavy', opacity: 0.9, snowy: true };
    }
    
    return { count: 'normal', opacity: 0.9 };
  }
  
  function getTemperatureDisplay(){
    if (!state.weather.enabled || !state.weather.data) return '';
    
    const unit = state.weather.tempUnit === 'auto' ? 'F' : state.weather.tempUnit;
    const temp = unit === 'F' ? state.weather.data.temp_f : state.weather.data.temp_c;
    
    // Calculate mercury height (0-100% based on temperature range)
    // For F: 0Â°F = 0%, 100Â°F = 100%
    // For C: -20Â°C = 0%, 40Â°C = 100%
    let mercuryPercent;
    if (unit === 'F') {
      mercuryPercent = Math.max(0, Math.min(100, ((temp - 0) / 100) * 100));
    } else {
      mercuryPercent = Math.max(0, Math.min(100, ((temp + 20) / 60) * 100));
    }
    
    return `<div class="thermometer" title="Current temperature: ${temp}Â°${unit}">
      <div class="thermo-tube">
        <div class="thermo-mercury" style="height:${mercuryPercent}%"></div>
      </div>
      <div class="thermo-bulb"></div>
      <div class="thermo-temp">${temp}Â°${unit}</div>
    </div>`;
  }

  function windowsill(){
    const currentSill = state.windowsills[state.currentSillIndex] || state.windowsills[0];
    const theme = WINDOWSILL_THEMES[currentSill.theme];
    const plants = currentSill.plants;
    let changed=false;
    
    const plantsHTML = plants.map((gp, idx, arr)=>{
      let hRatio = gp.galleryH;
      if (hRatio==null){
        const base = (TYPE_HEIGHT[gp.flowerStyle||'daisy']||0.42);
        const tier = Math.floor(Math.random()*HEIGHT_STEPS.length);
        hRatio = Math.max(0.34, Math.min(0.62, base + HEIGHT_STEPS[tier]));
        gp.galleryH=hRatio; gp.heightTier=tier; changed=true;
      }
      let x = gp.xPct; if (x==null){ x = ( (idx+1)/(arr.length+1) * 94 + 3 ); gp.xPct=x; changed=true; }
      
      // Add move button in arrange mode
      const moveButton = state.arrangeMode && state.windowsills.length > 1 ? 
        `<div style="position:absolute; top:4px; right:4px; z-index:10;">
          <button class="btn secondary" style="padding:6px 10px; font-size:11px;" data-action="show-move-picker" data-plant-index="${idx}">Move</button>
        </div>` : '';
      
      return `<div class="drag-plant ${state.arrangeMode? 'is-arrange':''}" data-gindex="${idx}" data-xpct="${x}" style="height: calc(var(--win-h) * ${hRatio}); left:0px;">
        ${moveButton}
        <div style="width:100%; height:92%; display:flex; align-items:flex-end; justify-content:center; overflow:visible">
          <div>${plantSVG({...gp, growth:100})}</div>
        </div>
      </div>`;
    }).join('');
    if (changed) save();

    const starContainer = buildStars();
    const cloudConfig = getCloudConfig();
    const weatherEffects = buildWeatherEffects();
    const tempDisplay = getTemperatureDisplay();
    
    const navLeft = state.currentSillIndex > 0 ? `<div class="sill-nav left" data-action="prev-sill">â€¹</div>` : '';
    const navRight = state.currentSillIndex < state.windowsills.length - 1 ? `<div class="sill-nav right" data-action="next-sill">â€º</div>` : '';
    const dots = state.windowsills.map((_, idx) => 
      `<div class="sill-dot ${idx === state.currentSillIndex ? 'active' : ''}" data-action="goto-sill" data-sill-index="${idx}"></div>`
    ).join('');
    
    // Adjust cloud rendering based on weather
    let clouds1HTML = '', clouds2HTML = '';
    if (cloudConfig.count !== 'none') {
      const opacity = cloudConfig.opacity;
      const color = cloudConfig.dark ? '#6b7280' : (cloudConfig.snowy ? '#e5e7eb' : '#fff');
      const cloudStyle = `opacity:${opacity}`;
      
      if (cloudConfig.count === 'light') {
        clouds1HTML = `<div id="clouds1" class="cloud-band" style="top: 40px; animation: cloudRL1 120s linear infinite; ${cloudStyle}">${cloud(110)}</div>`;
        clouds2HTML = `<div id="clouds2" class="cloud-band" style="top: calc(((var(--win-h) - var(--ground-h)) * 0.35) - 60px); animation: cloudRL2 180s linear infinite; ${cloudStyle}">${cloud(90)}</div>`;
      } else if (cloudConfig.count === 'heavy' || cloudConfig.count === 'storm') {
        clouds1HTML = `<div id="clouds1" class="cloud-band" style="top: 40px; animation: cloudRL1 120s linear infinite; ${cloudStyle}">${cloud(130)} ${cloud(160)} ${cloud(140)} ${cloud(110)}</div>`;
        clouds2HTML = `<div id="clouds2" class="cloud-band" style="top: calc(((var(--win-h) - var(--ground-h)) * 0.35) - 60px); animation: cloudRL2 180s linear infinite; ${cloudStyle}">${cloud(150)} ${cloud(120)} ${cloud(100)}</div>`;
      } else {
        clouds1HTML = `<div id="clouds1" class="cloud-band" style="top: 40px; animation: cloudRL1 120s linear infinite; ${cloudStyle}">${cloud(110)} ${cloud(150)} ${cloud(100)}</div>`;
        clouds2HTML = `<div id="clouds2" class="cloud-band" style="top: calc(((var(--win-h) - var(--ground-h)) * 0.35) - 60px); animation: cloudRL2 180s linear infinite; ${cloudStyle}">${cloud(130)} ${cloud(90)}</div>`;
      }
      
      // Apply dark cloud color if needed
      if (cloudConfig.dark || cloudConfig.snowy) {
        clouds1HTML = clouds1HTML.replace(/class="cloud"/g, `class="cloud" style="filter: brightness(${cloudConfig.dark ? 0.7 : 0.95})"`);
        clouds2HTML = clouds2HTML.replace(/class="cloud"/g, `class="cloud" style="filter: brightness(${cloudConfig.dark ? 0.7 : 0.95})"`);
      }
    }
    
    // Move picker modal
    const movePicker = state.movingPlantIndex !== null ? `
      <div style="position:absolute; inset:0; background:rgba(0,0,0,0.5); z-index:20; display:flex; align-items:center; justify-content:center;" data-action="cancel-move">
        <div style="background:white; border-radius:16px; padding:20px; max-width:400px; box-shadow:0 8px 24px rgba(0,0,0,0.2);" onclick="event.stopPropagation()">
          <div style="font-weight:600; margin-bottom:12px;">Move plant to which windowsill?</div>
          <div class="grid" style="gap:8px;">
            ${state.windowsills.map((sill, idx) => {
              const isCurrentSill = idx === state.currentSillIndex;
              return `<button class="btn ${isCurrentSill ? 'secondary' : 'primary'}" 
                      data-action="move-to-sill" 
                      data-target-sill="${idx}"
                      ${isCurrentSill ? 'disabled' : ''}>
                ${WINDOWSILL_THEMES[sill.theme].name} ${isCurrentSill ? '(current)' : `(${sill.plants.length} plants)`}
              </button>`;
            }).join('')}
          </div>
          <div style="margin-top:12px;">
            <button class="btn secondary" data-action="cancel-move" style="width:100%;">Cancel</button>
          </div>
        </div>
      </div>
    ` : '';
    
    return `<div class="card"><div class="content">
      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px">
        <div style="font-weight:600">${theme.name} (${plants.length} plants)</div>
        <button class="btn secondary" data-action="toggle-arrange">${state.arrangeMode? 'Done':'Arrange plants'}</button>
      </div>
      <div class="window" id="window-el" style="--ring:${theme.frameColor};">
        <div class="sky" id="sky-bg" style="${theme.bgTint ? 'background:linear-gradient('+theme.bgTint+', '+theme.bgTint+'), linear-gradient(var(--sky1), var(--sky2))' : ''}"></div>
        <div id="sun" class="sun"></div>
        <div id="moon" class="moon">
          <div class="moon-shadow" id="moon-shadow"></div>
        </div>
        ${clouds1HTML}
        ${clouds2HTML}
        ${weatherEffects}
        <div class="ground"></div>
        <div class="mullion-h"></div><div class="mullion-v"></div><div class="frame"></div>
        <div class="sill" style="background:${theme.sillColor}"></div>
        ${curtains()}
        ${starContainer.outerHTML}
        ${tempDisplay}
        ${navLeft}
        ${navRight}
        ${state.windowsills.length > 1 ? `<div class="sill-dots">${dots}</div>` : ''}
        <div class="window-inner">
          <div class="gallery-layer" id="gallery-layer">${plantsHTML}</div>
        </div>
        ${movePicker}
      </div>
    </div></div>`;
  }

  function breathingCards(){
    const now = Date.now();
    const showPrep = state.sessionActive && state.config.breathingEnabled && state.breathPrepUntil > now;
    const showBreath = state.sessionActive && state.config.breathingEnabled && state.cooldownUntil > now && state.breathPrepUntil===0;
    let out='';
    if (showPrep){
      const secLeft = Math.max(0, Math.ceil((state.breathPrepUntil - now)/1000));
      out += `<div class="card"><div class="content" style="text-align:center">
        <div style="font-weight:600">Get ready to breathe</div>
        <div class="small-note">Starting in ${secLeft}â€¦</div></div></div>`;
    }
    if (showBreath){
      const phases = state.config.breathPhases; const total = phases.reduce((a,b)=>a+b,0);
      const elapsed = Math.max(0, total - (state.cooldownUntil - now)/1000);
      const cum = [phases[0], phases[0]+phases[1], phases[0]+phases[1]+phases[2]];
      let idx=0; for(let i=0;i<cum.length;i++){ if (elapsed<cum[i]){ idx=i; break; } }
      const names=["Inhale","Hold","Exhale"]; const phaseStart=(idx===0?0:cum[idx-1]); const phaseLen=phases[idx];
      const secLeft = Math.max(0, Math.ceil(phaseLen - (elapsed - phaseStart)));
      const minSize=24, maxSize=56; const prog = Math.max(0, Math.min(1, (elapsed - phaseStart)/phaseLen ));
      let size = (idx===0)? (minSize + (maxSize-minSize)*prog) : (idx===1? maxSize : (minSize + (maxSize-minSize)*(1-prog)));
      const counts = Array.from({length:secLeft},(_,i)=> secLeft-i-1).filter(x=>x>=0).map(x=>` ${x}â€¦`).join('');
      out += `<div class="card"><div class="content" style="text-align:center">
        <div style="font-weight:600">Mindful pause</div>
        <div style="width:160px;height:160px;border:2px solid #94a3b8;margin:8px auto;border-radius:12px;display:flex;align-items:center;justify-content:center">
          <div style="width:${size}px;height:${size}px;border-radius:999px;background:rgba(16,185,129,.25);transition:width .2s,height .2s"></div>
        </div>
        <div>${names[idx]} ${secLeft} sec<span class="small-note">${counts}</span></div>
      </div></div>`;
    }
    if (state.lastFact){ out += `<div class="sign"><div class="title">Garden note</div><p>ðŸ’¡ ${state.lastFact}</p></div>`; }
    return out;
  }

  function statusBar(){
    const {h, m} = parseUnlockTime();
    const totalPlants = getTotalPlantCount();
    return `<div class="card"><div class="content">
      <div class="status-grid">
        <div class="status-item">
          <div class="label">Today</div><div class="value">${state.day.date}</div>
          <div class="row" style="margin-top:6px">
            <button class="btn primary" data-action="start" ${state.sessionActive || isLocked() || (state.day.actionsRemaining<=0 && !state.unlimitedActions) ? 'disabled':''}>Start Session</button>
            <button class="btn secondary" data-action="end" ${!state.sessionActive ? 'disabled':''}>End Session</button>
          </div>
        </div>
        <div class="status-item"><div class="label">Actions left</div><div class="value">${state.unlimitedActions? 'âˆž (dev)' : Math.max(0, Math.ceil(state.day.actionsRemaining))}</div></div>
        <div class="status-item"><div class="label">Streak</div><div class="value">${state.streak} day${state.streak===1?'':'s'}</div></div>
        <div class="status-item"><div class="label">Total plants</div><div class="value">${totalPlants}</div></div>
        <div class="status-item"><div class="label">Windowsills</div><div class="value">${state.windowsills.length}</div></div>
        <div class="status-item"><div class="label">Daily unlock</div><div class="value">${toAmPm(h, m)}</div></div>
      </div>
    </div></div>`;
  }

  function unlockNotice(){
    if (!isLocked()) return '';
    const ms = nextUnlock().getTime() - Date.now();
    const s = Math.max(0, Math.floor(ms / 1000));
    const h = Math.floor(s / 3600);
    const m = Math.floor((s % 3600) / 60);
    const r = s % 60;
    const t = h > 0 ? `${h}:${fmt2(m)}:${fmt2(r)}` : `${fmt2(m)}:${fmt2(r)}`;
    return `<div class="card"><div class="content small-note">Content unlocks daily at ${state.config.unlockTimeText}. Next unlock in ${t}.</div></div>`;
  }

  function generalSettings(){
    const [inh,hold,exh] = state.config.breathPhases;
    return `<div class="card"><div class="content">
      <div style="font-weight:600; margin-bottom:8px">Settings</div>
      <div class="row" style="gap:12px">
        <label class="row" style="gap:6px"><input type="checkbox" data-action="toggle-breath" ${state.config.breathingEnabled?'checked':''}><span class="small">Breathing enabled</span></label>
        <label class="row" style="gap:6px"><span class="small">Turns between breaths</span><input class="input" type="number" style="width:90px" data-action="set-turns-between" value="${state.config.turnsBetweenBreaths}"></label>
        <label class="row" style="gap:6px"><span class="small">Inhale</span><input class="input" type="number" style="width:70px" data-action="set-inhale" value="${inh}"><span class="small">Hold</span><input class="input" type="number" style="width:70px" data-action="set-hold" value="${hold}"><span class="small">Exhale</span><input class="input" type="number" style="width:70px" data-action="set-exhale" value="${exh}"></label>
      </div>
      <div class="row" style="gap:12px; margin-top:10px">
        <label class="row" style="gap:6px"><input type="checkbox" data-action="toggle-postpause" ${state.config.postActionPauseEnabled?'checked':''}><span class="small">Post-action pause</span></label>
        <label class="row" style="gap:6px"><span class="small">Seconds</span><input class="input" type="number" style="width:90px" data-action="set-postpause-sec" value="${state.config.postActionPauseSec}"></label>
      </div>
      <div class="row" style="gap:12px; margin-top:10px">
        <label class="row" style="gap:6px"><input type="checkbox" data-action="toggle-location" ${state.location.geoEnabled?'checked':''}><span class="small">Use my location for sunrise/sunset (beta)</span></label>
      </div>
      ${state.location.geoEnabled ? `
        <div class="row" style="gap:8px; margin-top:8px"><span class="small">Change location:</span><button class="btn secondary" data-action="request-location">Re-request location</button><button class="btn secondary" data-action="use-fallback">Use fallback city</button></div>
        ${state.location.denied ? '<div class="small-note" style="margin-top:4px">Using fallback city (Chicago).</div>' : ''}
      ` : ''}
      <div class="row" style="gap:12px; margin-top:10px">
        <label class="row" style="gap:6px"><input type="checkbox" data-action="toggle-weather" ${state.weather.enabled?'checked':''}><span class="small">Show real weather (requires location)</span></label>
      </div>
      ${state.weather.enabled ? `
        <div class="row" style="gap:8px; margin-top:8px">
          <span class="small">Temperature:</span>
          <label class="row" style="gap:4px"><input type="radio" name="temp-unit" data-action="set-temp-unit" value="F" ${state.weather.tempUnit==='F'?'checked':''}><span class="small">Â°F</span></label>
          <label class="row" style="gap:4px"><input type="radio" name="temp-unit" data-action="set-temp-unit" value="C" ${state.weather.tempUnit==='C'?'checked':''}><span class="small">Â°C</span></label>
          ${state.weather.data ? `<span class="small">(${state.weather.data.condition})</span>` : '<span class="small">(fetching...)</span>'}
        </div>
        ${!state.weather.data ? '<div class="small-note" style="margin-top:4px">Weather data will appear once location is obtained and API responds.</div>' : ''}
      ` : ''}
      <div class="row" style="margin-top:12px">
        <button class="btn" data-action="soft-reset" style="border-color:#2563eb; color:#1d4ed8">Soft reset (today only)</button>
        <button class="btn" data-action="reset-game" style="border-color:#ef4444; color:#b91c1c">Reset game (erase progress)</button>
        <span class="small">Soft reset keeps your windowsills & streaks; hard reset clears everything.</span>
      </div>
    </div></div>`;
  }

  function devSettings(){
    const [inh,hold,exh] = state.config.breathPhases;
    return `<div class="card"><div class="content">
      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px">
        <div style="font-weight:600">Developer mode</div>
        <label class="row" style="gap:6px"><input type="checkbox" data-action="toggle-dev-mode" ${state.devMode?'checked':''}><span class="small">Enable</span></label>
      </div>
      ${state.devMode ? `
        <div class="grid" style="grid-template-columns:repeat(3,minmax(0,1fr)); gap:12px">
          <label><div class="small">Daily actions</div><input class="input" type="number" data-action="set-daily-actions" value="${state.config.dailyActions}"></label>
          <label><div class="small">Actions to mature</div><input class="input" type="number" data-action="set-actions-mature" value="${state.config.actionsToMature}"></label>
          <label><div class="small">Unlimited actions</div><div class="row"><input type="checkbox" data-action="toggle-unlimited" ${state.unlimitedActions?'checked':''}><span class="small">Enable</span></div></label>
        </div>
        <div class="grid" style="grid-template-columns:1fr; gap:12px; margin-top:8px">
          <label class="row" style="gap:6px"><input type="checkbox" data-action="toggle-dev-override" ${state.devTimeOverride?'checked':''}><span class="small">Override location/astronomy with dev time</span></label>
          <label><div class="small">Time of day (simulated)</div>
            <input type="range" min="0" max="24" step="0.05" value="${state.devSliderHour}" data-action="set-dev-hour" style="width:100%" ${state.devTimeOverride?'':'disabled'}>
            <div class="small">Current: ${formatHour(state.devSliderHour)}</div>
          </label>
        </div>
        <div class="grid" style="grid-template-columns:1fr; gap:12px; margin-top:8px">
          <label><div class="small">Advance days</div><div class="row"><input class="input" type="number" min="1" step="1" value="1" data-action="dev-advance-days"><button class="btn secondary" data-action="do-advance-days">Advance</button></div></label>
        </div>
        <div class="small" style="margin-top:8px">Breathing: <strong>${state.config.breathingEnabled? 'enabled':'disabled'}</strong>, every ${state.config.turnsBetweenBreaths} turns; ${inh}-${hold}-${exh}s. Post-action pause: ${state.config.postActionPauseEnabled? state.config.postActionPauseSec + 's':'off'}.</div>
      }` : `<div class="small">Turn on Developer mode for extra controls (time slider, unlimited actions, etc.).</div>`}
    </div></div>`;
  }

  function formatHour(h){ const hh=Math.floor(h); const mm=Math.round((h-hh)*60); const period = hh>=12 ? "p.m." : "a.m."; const dispH = ((hh%12)||12); return `${dispH}:${fmt2(mm)} ${period}`; }
  function settingsPanel(){ return `${generalSettings()}${devSettings()}`; }
  function footerNote(){ return `<div class="small-note">Multiple windowsills unlock every 5 plants. Swipe or use arrows to navigate. In Arrange mode, use the "Move" button to transfer plants between windowsills! Enable real weather in Settings to see current conditions.</div>`; }

  function softResetToday(){
    const ok = confirm("Soft reset today? Keeps windowsills & streaks; resets today's plant and actions.");
    if (!ok) return;
    state.day = { date: todayKey(), actionsRemaining: state.config.dailyActions, plants: [DEFAULT_PLANT()], playedToday:false };
    state.sessionActive=false; state.cooldownUntil=0; state.breathPrepUntil=0; state.postPauseUntil=0; state.actionCount=0; state.lastFact='';
    save(); render();
  }
  function hardResetGame(){
    const ok = confirm("Reset Mind Garden? This will erase all progress and settings.");
    if (!ok) return;
    try{ Object.keys(localStorage).filter(k=>k.startsWith('mind-garden')).forEach(k=>localStorage.removeItem(k)); }catch(e){ console.warn(e); }
    location.reload();
  }

  function positionPlantsFromPct(){
    const gallery = document.getElementById('gallery-layer');
    if (!gallery) return;
    const rect = gallery.getBoundingClientRect();
    const currentSill = state.windowsills[state.currentSillIndex];
    if (!currentSill) return;
    const els = gallery.querySelectorAll('.drag-plant');
    els.forEach((el, idx)=>{
      const xPct = (currentSill.plants[idx] && typeof currentSill.plants[idx].xPct==='number') ? currentSill.plants[idx].xPct : +el.getAttribute('data-xpct') || 50;
      const centerX = (xPct/100) * rect.width;
      const w = el.getBoundingClientRect().width || 0;
      let leftPx = centerX - w/2;
      leftPx = Math.max(0, Math.min(rect.width - w, leftPx));
      el.style.left = leftPx + 'px';
    });
  }

  function bind(){
    const app = document.getElementById('app');
    app.querySelectorAll('[data-action]').forEach(node=>{
      const action = node.getAttribute('data-action');
      node.addEventListener('click', (ev)=>{
        if (action==='start') startSession();
        else if (action==='end') endSession();
        else if (action==='tend') tend(+node.getAttribute('data-index'));
        else if (action==='place-on-sill'){ 
          const plantIdx=+node.getAttribute('data-plant-index'); 
          const sillIdx=+node.getAttribute('data-sill-index'); 
          placePlantFromIndex(plantIdx, sillIdx); 
        }
        else if (action==='toggle-arrange'){ state.arrangeMode=!state.arrangeMode; state.movingPlantIndex=null; save(); render(); }
        else if (action==='show-move-picker'){ 
          state.movingPlantIndex = +node.getAttribute('data-plant-index'); 
          save(); render(); 
        }
        else if (action==='move-to-sill'){ 
          const targetSill = +node.getAttribute('data-target-sill');
          if (state.movingPlantIndex !== null) {
            movePlantBetweenSills(state.currentSillIndex, state.movingPlantIndex, targetSill);
          }
        }
        else if (action==='cancel-move'){ 
          state.movingPlantIndex = null; 
          save(); render(); 
        }
        else if (action==='prev-sill'){ if (state.currentSillIndex > 0) { state.currentSillIndex--; save(); render(); } }
        else if (action==='next-sill'){ if (state.currentSillIndex < state.windowsills.length - 1) { state.currentSillIndex++; save(); render(); } }
        else if (action==='goto-sill'){ state.currentSillIndex = +node.getAttribute('data-sill-index'); save(); render(); }
        else if (action==='do-advance-days'){ const input = app.querySelector('[data-action="dev-advance-days"]'); const n = Math.max(1, parseInt(input.value||'1',10)); state.streak += n; state.day.playedToday=false; save(); render(); }
        else if (action==='reset-game'){ hardResetGame(); }
        else if (action==='soft-reset'){ softResetToday(); }
        else if (action==='lock-type'){ const i=+node.getAttribute('data-index'); const p=state.day.plants[i]; if (p.flowerStyle==='bell' && (p.bellDir==null)) p.bellDir = (Math.random()<0.5?-1:1); p.styleLocked=true; save(); render(); }
      });
    });

    // style/color linkage
    app.querySelectorAll('select[data-action="set-style"]').forEach(sel=>{
      sel.addEventListener('change', ()=>{
        const i = +sel.getAttribute('data-index');
        const newStyle = sel.value;
        const p = state.day.plants[i];
        p.flowerStyle = newStyle;
        const allowed = STYLE_COLORS[newStyle] || ["pink"];
        p.flowerColor = allowed[0];
        if (newStyle==='bell' && (p.bellDir==null)) p.bellDir = (Math.random()<0.5?-1:1);
        save(); render();
      });
    });
    app.querySelectorAll('select[data-action="set-color"]').forEach(sel=>{
      sel.addEventListener('change', ()=>{
        const i = +sel.getAttribute('data-index');
        const chosen = sel.value;
        const style = state.day.plants[i].flowerStyle;
        const allowed = STYLE_COLORS[style] || [];
        if (allowed.includes(chosen)){
          state.day.plants[i].flowerColor = chosen;
          save();
        } else {
          state.day.plants[i].flowerColor = allowed[0] || chosen;
          save(); render();
        }
      });
    });
    app.querySelectorAll('select[data-action="set-pot"]').forEach(sel=>{
      sel.addEventListener('change', ()=>{
        const i = +sel.getAttribute('data-index');
        state.day.plants[i].potStyle = sel.value;
        save(); render();
      });
    });

    const tb = app.querySelector('[data-action="set-turns-between"]');
    if (tb) tb.addEventListener('input', ()=>{ state.config.turnsBetweenBreaths = Math.max(1, +tb.value||1); save(); });

    const br = app.querySelector('[data-action="toggle-breath"]');
    if (br) br.addEventListener('change', ()=>{ state.config.breathingEnabled = br.checked; save(); renderBreathingOnly(); });

    const inh = app.querySelector('[data-action="set-inhale"]');
    if (inh) inh.addEventListener('input', ()=>{ state.config.breathPhases[0] = Math.max(1, +inh.value||1); save(); renderBreathingOnly(); });
    const hld = app.querySelector('[data-action="set-hold"]');
    if (hld) hld.addEventListener('input', ()=>{ state.config.breathPhases[1] = Math.max(0, +hld.value||0); save(); renderBreathingOnly(); });
    const exh = app.querySelector('[data-action="set-exhale"]');
    if (exh) exh.addEventListener('input', ()=>{ state.config.breathPhases[2] = Math.max(1, +exh.value||1); save(); renderBreathingOnly(); });

    const pp = app.querySelector('[data-action="toggle-postpause"]');
    if (pp) pp.addEventListener('change', ()=>{ state.config.postActionPauseEnabled = pp.checked; if (!pp.checked){ state.postPauseUntil=0; state.__ppActive=false; } save(); });

    const pps = app.querySelector('[data-action="set-postpause-sec"]');
    if (pps) pps.addEventListener('input', ()=>{ state.config.postActionPauseSec = Math.max(0, +pps.value||0); save(); });

    const locToggle = app.querySelector('[data-action="toggle-location"]');
    if (locToggle) locToggle.addEventListener('change', ()=>{ state.location.geoEnabled = locToggle.checked; if (locToggle.checked){ state.location.denied=false; initLocationAstronomy(); } save(); render(); });
    const reqLoc = app.querySelector('[data-action="request-location"]');
    if (reqLoc) reqLoc.addEventListener('click', ()=>{ 
      state.location.denied=false; 
      state.location.coords=null; 
      save(); 
      initLocationAstronomy(); 
      render(); 
    });
    const fbLoc = app.querySelector('[data-action="use-fallback"]');
    if (fbLoc) fbLoc.addEventListener('click', ()=>{ 
      state.location.coords=FALLBACK_LOC; 
      state.location.denied=true; 
      save(); 
      if (state.weather.enabled) fetchWeather();
      render(); 
    });

    const weatherToggle = app.querySelector('[data-action="toggle-weather"]');
    if (weatherToggle) weatherToggle.addEventListener('change', ()=>{ 
      state.weather.enabled = weatherToggle.checked; 
      if (weatherToggle.checked) {
        // Enable location if not already enabled
        if (!state.location.geoEnabled) {
          state.location.geoEnabled = true;
          state.location.denied = false;
        }
        // Start location/weather fetch
        save();
        initLocationAstronomy();
      } else {
        save();
      }
      render(); 
    });
    
    app.querySelectorAll('[data-action="set-temp-unit"]').forEach(radio => {
      radio.addEventListener('change', ()=> {
        if (radio.checked) {
          state.weather.tempUnit = radio.value;
          save(); render();
        }
      });
    });

    const dm = app.querySelector('[data-action="toggle-dev-mode"]');
    if (dm) dm.addEventListener('change', ()=>{ state.devMode = dm.checked; save(); render(); });

    const da = app.querySelector('[data-action="set-daily-actions"]');
    if (da) da.addEventListener('input', ()=>{ state.config.dailyActions = Math.max(1, +da.value||0); if (!state.unlimitedActions) state.day.actionsRemaining = state.config.dailyActions; save(); });

    const atm = app.querySelector('[data-action="set-actions-mature"]');
    if (atm) atm.addEventListener('input', ()=>{ state.config.actionsToMature = Math.max(1, +atm.value||1); save(); });

    const ua = app.querySelector('[data-action="toggle-unlimited"]');
    if (ua) ua.addEventListener('change', ()=>{ state.unlimitedActions = ua.checked; save(); render(); });

    const dh = app.querySelector('[data-action="set-dev-hour"]');
    if (dh) dh.addEventListener('input', ()=>{ state.devSliderHour = +dh.value; save(); positionAstronomy(); });
    const dov = app.querySelector('[data-action="toggle-dev-override"]');
    if (dov) dov.addEventListener('change', ()=>{ state.devTimeOverride = dov.checked; save(); render(); });

    // DRAG along sill (X only) in arrange mode â€” pixel-based left positioning
    const win = app.querySelector('#window-el');
    const gallery = app.querySelector('#gallery-layer');
    let draggingIdx = null;

    function clientX(evt){ return (evt.touches && evt.touches[0]?.clientX) || evt.clientX; }

    function onDown(evt){
      if (!state.arrangeMode) return;
      const target = evt.target.closest('.drag-plant');
      if (!target) return;
      draggingIdx = +target.getAttribute('data-gindex');
      target.classList.add('dragging');
      evt.preventDefault();
    }
    function onMove(evt){
      if (draggingIdx==null || !state.arrangeMode) return;
      const rect = gallery.getBoundingClientRect();
      const el = gallery.querySelector('.drag-plant[data-gindex="'+draggingIdx+'"]');
      if (!el) return;
      const w = el.getBoundingClientRect().width || 0;
      const cx = clamp(clientX(evt) - rect.left, 0, rect.width);
      let leftPx = cx - w/2;
      leftPx = Math.max(0, Math.min(rect.width - w, leftPx));
      el.style.left = leftPx + 'px';
      const xPct = (cx / rect.width) * 100;
      const currentSill = state.windowsills[state.currentSillIndex];
      if (currentSill && currentSill.plants[draggingIdx]) currentSill.plants[draggingIdx].xPct = xPct;
    }
    function onUp(){
      if (draggingIdx==null) return;
      const el = gallery.querySelector('.drag-plant[data-gindex="'+draggingIdx+'"]');
      if (el){ el.classList.remove('dragging'); }
      draggingIdx = null;
      save();
    }
    
    // Swipe detection for mobile
    let touchStartX = 0;
    let touchEndX = 0;
    
    function handleSwipe(){
      const swipeThreshold = 50;
      if (touchEndX < touchStartX - swipeThreshold && state.currentSillIndex < state.windowsills.length - 1) {
        state.currentSillIndex++;
        save(); render();
      }
      if (touchEndX > touchStartX + swipeThreshold && state.currentSillIndex > 0) {
        state.currentSillIndex--;
        save(); render();
      }
    }
    
    win.addEventListener('touchstart', e => {
      if (!state.arrangeMode) {
        touchStartX = e.changedTouches[0].screenX;
      }
    });
    
    win.addEventListener('touchend', e => {
      if (!state.arrangeMode) {
        touchEndX = e.changedTouches[0].screenX;
        handleSwipe();
      }
    });
    
    win.addEventListener('mousedown', onDown);
    win.addEventListener('touchstart', onDown, {passive:false});
    window.addEventListener('mousemove', onMove);
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp);
    window.addEventListener('touchend', onUp);

    positionPlantsFromPct();
    window.addEventListener('resize', positionPlantsFromPct);
  }

  function getCssNumber(varName){ const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); return parseFloat(v.replace('px','')); }
  function currentTime(){
    if (state.devMode && state.devTimeOverride){
      const now = new Date();
      const h = Math.floor(state.devSliderHour);
      const m = Math.floor((state.devSliderHour - h)*60);
      const s = Math.floor(((state.devSliderHour - h)*60 - m)*60);
      now.setHours(h,m,s,0);
      return now;
    }
    return new Date();
  }

  function initLocationAstronomy(){
    if (!state.location?.geoEnabled) return;
    if (state.location.coords || state.location.denied) {
      // If we already have location or it's denied, and weather is enabled, fetch it
      if (state.weather.enabled) {
        fetchWeather();
      }
      return;
    }
    if (navigator.geolocation){
      navigator.geolocation.getCurrentPosition(pos=>{
        state.location.coords = {lat: pos.coords.latitude, lon: pos.coords.longitude};
        state.location.denied=false;
        save(); 
        positionAstronomy(); 
        if (state.weather.enabled) fetchWeather();
        render();
      }, err=>{
        // Location denied or failed - use fallback
        state.location.coords=FALLBACK_LOC;
        state.location.denied=true;
        save(); 
        positionAstronomy(); 
        if (state.weather.enabled) fetchWeather();
        render();
      }, {timeout:10000});
    } else {
      // Geolocation not available - use fallback
      state.location.coords=FALLBACK_LOC;
      state.location.denied=true;
      save();
      if (state.weather.enabled) fetchWeather();
    }
  }

  // Fetch weather from Open-Meteo API
  async function fetchWeather(){
    if (!state.weather.enabled) return;
    
    const now = Date.now();
    if (state.weather.data && (now - state.weather.lastFetch < WEATHER_CACHE_MS)) {
      return; // Use cached data
    }
    
    // Use stored coords or fallback
    let loc = state.location.coords;
    if (!loc || (loc.lat === undefined || loc.lon === undefined)) {
      loc = FALLBACK_LOC;
      console.log('Using fallback location for weather:', loc);
    }
    
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${loc.lat}&longitude=${loc.lon}&current=temperature_2m,weather_code,cloud_cover,precipitation&temperature_unit=fahrenheit&timezone=auto`;
    
    console.log('Fetching weather from:', url);
    
    try {
      const response = await fetch(url);
      if (!response.ok) {
        console.error('Weather API returned error:', response.status, response.statusText);
        return;
      }
      
      const data = await response.json();
      console.log('Weather data received:', data);
      
      if (data.current) {
        state.weather.data = {
          temp_f: Math.round(data.current.temperature_2m),
          temp_c: Math.round((data.current.temperature_2m - 32) * 5/9),
          weatherCode: data.current.weather_code,
          condition: WEATHER_CODES[data.current.weather_code] || 'clear',
          cloudCover: data.current.cloud_cover || 0,
          precipitation: data.current.precipitation || 0
        };
        state.weather.lastFetch = now;
        
        // Auto-set temp unit based on location if set to 'auto'
        if (state.weather.tempUnit === 'auto') {
          // US uses Fahrenheit, most other places use Celsius
          const usesF = loc.lat > 24 && loc.lat < 50 && loc.lon > -125 && loc.lon < -65;
          state.weather.tempUnit = usesF ? 'F' : 'C';
        }
        
        console.log('Weather data processed:', state.weather.data);
        save();
        render();
      }
    } catch (error) {
      // Silently fail - weather is optional, game continues working
      console.error('Weather fetch failed:', error);
    }
  }

  function computeSunMoon(now, lat, lon){
    const times = SunCalc.getTimes(now, lat, lon);
    const sunrise=times.sunrise.getTime(), sunset=times.sunset.getTime();
    const dawn=times.dawn.getTime(), dusk=times.dusk.getTime();
    const nowMs = now.getTime();
    const prev = SunCalc.getTimes(new Date(nowMs - 86400000), lat, lon);
    const next = SunCalc.getTimes(new Date(nowMs + 86400000), lat, lon);
    const dayT = clamp((nowMs - sunrise)/(sunset - sunrise),0,1);
    let nightT;
    if (nowMs >= sunset) nightT = (nowMs - sunset)/(next.sunrise.getTime() - sunset);
    else if (nowMs < sunrise) nightT = (nowMs - prev.sunset.getTime())/(sunrise - prev.sunset.getTime());
    else nightT = 0;
    nightT = clamp(nightT,0,1);
    let darkness=0;
    if (nowMs < dawn || nowMs >= dusk) darkness=1;
    else if (nowMs >= dawn && nowMs < sunrise) darkness = 1 - (nowMs - dawn)/(sunrise - dawn);
    else if (nowMs >= sunset && nowMs < dusk) darkness = (nowMs - sunset)/(dusk - sunset);
    const duskF = (nowMs >= sunset && nowMs < dusk) ? (nowMs - sunset)/(dusk - sunset) : 0;
    const dawnF = (nowMs >= dawn && nowMs < sunrise) ? (sunrise - nowMs)/(sunrise - dawn) : 0;
    const moonPos = SunCalc.getMoonPosition(now, lat, lon);
    const moonIllum = SunCalc.getMoonIllumination(now);
    return {dayT, nightT, darkness, dusk:duskF, dawn:dawnF, moonPos, moonIllum};
  }

  function nowHour(){
    if (state.devMode && state.devTimeOverride) return state.devSliderHour;
    const now = new Date();
    return now.getHours() + now.getMinutes()/60 + now.getSeconds()/3600;
  }

  function updateMoonPhase(moonElement, shadowElement, illumination) {
    if (!illumination) return;
    const { fraction, phase } = illumination;
    if (fraction >= 0.99) {
      shadowElement.style.opacity = '0';
    } else if (fraction <= 0.01) {
      shadowElement.style.opacity = '1';
      shadowElement.style.transform = 'translateX(0%)';
    } else {
      shadowElement.style.opacity = '1';
      let shadowOffset;
      if (phase < 0.5) {
        shadowOffset = -100 + (phase * 2 * 100);
      } else {
        shadowOffset = 100 - ((phase - 0.5) * 2 * 100);
      }
      shadowElement.style.transform = `translateX(${shadowOffset}%)`;
    }
  }

  function positionAstronomy(){
    const winH = getCssNumber('--win-h'), groundH=getCssNumber('--ground-h');
    const grassTopPct = ((winH - groundH)/winH)*100;
    const sun=document.getElementById('sun'), moon=document.getElementById('moon'), sky=document.getElementById('sky-bg');
    const clouds1=document.getElementById('clouds1'), clouds2=document.getElementById('clouds2'), stars=document.querySelector('.stars');
    const amp=28;
    if (!state.location.geoEnabled){
      const hour = nowHour();
      const dayT = Math.max(0, Math.min(1, (hour - SUNRISE_H)/(SUNSET_H - SUNRISE_H) ));
      const xSun = 1.5 + 97*dayT, ySun = grassTopPct - amp*Math.sin(Math.PI*dayT);
      let nightT; if (hour>=SUNSET_H) nightT = (hour - SUNSET_H)/(24 - SUNSET_H + SUNRISE_H); else if (hour<SUNRISE_H) nightT = (hour + (24 - SUNSET_H))/(24 - SUNSET_H + SUNRISE_H); else nightT=0; nightT=Math.max(0, Math.min(1, nightT));
      const xMoon = 98.5 - 97*nightT, yMoon = grassTopPct - amp*Math.sin(Math.PI*nightT);
      if (sun){ sun.style.left = xSun+'%'; sun.style.top = ySun+'%'; }
      if (moon){ moon.style.left = xMoon+'%'; moon.style.top = yMoon+'%'; }
      function twilightFactor(centerHour){ const diff=Math.abs(hour-centerHour); if (diff>0.5) return 0; return 0.5*(1+Math.cos(Math.PI*(diff/0.5))); }
      const dusk=twilightFactor(SUNSET_H), dawn=twilightFactor(SUNRISE_H);
      let darkBase = (hour < SUNRISE_H || hour >= SUNSET_H) ? 1 : 0;
      const darkness = Math.max(0, Math.min(1, darkBase + dusk*(1-darkBase) - dawn*darkBase ));
      if (sky){
        const dayTop = getComputedStyle(document.documentElement).getPropertyValue('--sky1').trim();
        const dayBot = getComputedStyle(document.documentElement).getPropertyValue('--sky2').trim();
        const nightTop='#071a3a', nightBot='#0b2447';
        function mix(c1,c2,t){ function hexToRgb(h){h=h.replace('#',''); return {r:parseInt(h.slice(0,2),16), g:parseInt(h.slice(2,4),16), b:parseInt(h.slice(4,6),16)};}
          function rgbToHex(r,g,b){const H=(n)=>n.toString(16).padStart(2,'0'); return '#'+H(r)+H(g)+H(b);}
          const a=hexToRgb(c1), b=hexToRgb(c2);
          return rgbToHex(Math.round(a.r+(b.r-a.r)*t), Math.round(a.g+(b.g-a.g)*t), Math.round(a.b+(b.b-a.b)*t));
        }
        const currentSky = sky.style.background;
        const isTinted = currentSky.includes('linear-gradient') && currentSky.split('linear-gradient').length > 2;
        let baseGradient;
        if (isTinted) {
          const parts = currentSky.split('), linear-gradient(');
          baseGradient = 'linear-gradient(' + parts[1];
        } else {
          baseGradient = currentSky;
        }
        const top=mix(dayTop, nightTop, darkness), bot=mix(dayBot, nightBot, darkness);
        const currentSill = state.windowsills[state.currentSillIndex];
        const theme = currentSill ? WINDOWSILL_THEMES[currentSill.theme] : WINDOWSILL_THEMES[0];
        if (theme.bgTint) {
          sky.style.background = `linear-gradient(${theme.bgTint}, ${theme.bgTint}), linear-gradient(${top}, ${bot})`;
        } else {
          sky.style.background = `linear-gradient(${top}, ${bot})`;
        }
      }
      const cloudOpacity = 0.9*(1-darkness);
      if (clouds1) clouds1.style.opacity = cloudOpacity;
      if (clouds2) clouds2.style.opacity = cloudOpacity;
      if (stars) stars.style.opacity = darkness;
      if (sun)  sun.style.opacity  = (dayT>0 && dayT<1) ? (0.9 * (1 - dusk)) : 0;
      if (moon) moon.style.opacity = (nightT>0 && nightT<1) ? (0.8 * (1 - dawn)) : 0;
	  if (moon && document.getElementById('moon-shadow')) {
        const now = currentTime();
        const moonIllum = SunCalc.getMoonIllumination(now);
        updateMoonPhase(moon, document.getElementById('moon-shadow'), moonIllum);
      }
    } else {
      const loc = state.location.coords || FALLBACK_LOC;
      const now = currentTime();
      const astro = computeSunMoon(now, loc.lat, loc.lon);
      const xSun = 1.5 + 97*astro.dayT, ySun = grassTopPct - amp*Math.sin(Math.PI*astro.dayT);
      const xMoon = 98.5 - 97*astro.nightT;
      const moonAlt = Math.max(0, Math.sin(astro.moonPos.altitude));
      const yMoon = grassTopPct - amp*moonAlt;
      if (sun){ sun.style.left = xSun+'%'; sun.style.top = ySun+'%'; }
      if (moon){ moon.style.left = xMoon+'%'; moon.style.top = yMoon+'%'; }
      if (sky){
        const dayTop = getComputedStyle(document.documentElement).getPropertyValue('--sky1').trim();
        const dayBot = getComputedStyle(document.documentElement).getPropertyValue('--sky2').trim();
        const nightTop='#071a3a', nightBot='#0b2447';
        function mix(c1,c2,t){ function hexToRgb(h){h=h.replace('#',''); return {r:parseInt(h.slice(0,2),16), g:parseInt(h.slice(2,4),16), b:parseInt(h.slice(4,6),16)};}
          function rgbToHex(r,g,b){const H=(n)=>n.toString(16).padStart(2,'0'); return '#'+H(r)+H(g)+H(b);}
          const a=hexToRgb(c1), b=hexToRgb(c2);
          return rgbToHex(Math.round(a.r+(b.r-a.r)*t), Math.round(a.g+(b.g-a.g)*t), Math.round(a.b+(b.b-a.b)*t));
        }
        const top=mix(dayTop, nightTop, astro.darkness), bot=mix(dayBot, nightBot, astro.darkness);
        const currentSill = state.windowsills[state.currentSillIndex];
        const theme = currentSill ? WINDOWSILL_THEMES[currentSill.theme] : WINDOWSILL_THEMES[0];
        if (theme.bgTint) {
          sky.style.background = `linear-gradient(${theme.bgTint}, ${theme.bgTint}), linear-gradient(${top}, ${bot})`;
        } else {
          sky.style.background = `linear-gradient(${top}, ${bot})`;
        }
      }
      const cloudOpacity = 0.9*(1-astro.darkness);
      if (clouds1) clouds1.style.opacity = cloudOpacity;
      if (clouds2) clouds2.style.opacity = cloudOpacity;
      if (stars) stars.style.opacity = astro.darkness;
      if (sun)  sun.style.opacity  = (astro.dayT>0 && astro.dayT<1) ? (0.9 * (1 - astro.dusk)) : 0;
      if (moon){
        let mop = (astro.nightT>0 && astro.nightT<1) ? (0.8 * (1 - astro.dawn)) : 0;
        mop *= (0.6 + 0.4*astro.moonIllum.fraction);
        moon.style.opacity = mop;
        const scale = 0.75 + 0.25*astro.moonIllum.fraction;
        moon.style.transform = `translate(-50%, -50%) scale(${scale})`;
      }
	  if (moon && document.getElementById('moon-shadow')) {
        updateMoonPhase(moon, document.getElementById('moon-shadow'), astro.moonIllum);
      }
    }
  }

  function garden(){ return garden._html(); }
  garden._html = function(){
    if (state.day.plants.length > 1) state.day.plants = state.day.plants.slice(0,1);
    return `<div class="plants-grid">${state.day.plants.map(plantCard).join('')}</div>`;
  };

  function renderBreathingOnly(){ const panel=document.getElementById('breathing-panel'); if (panel) panel.innerHTML = breathingCards(); }

  function render(){
    const app = document.getElementById('app');
    app.innerHTML = `<h1>Mind Garden <span class="tag">Prototype</span></h1>${statusBar()}${unlockNotice()}<div id="breathing-panel">${breathingCards()}</div>${garden()}${windowsill()}${settingsPanel()}${footerNote()}`;
    bind(); positionAstronomy();
  }

  setInterval(()=>{
    positionAstronomy();
    const now = Date.now();
    if (now < state.postPauseUntil) {
      if (!state.__ppActive) state.__ppActive = true;
      render();
    } else {
      if (state.__ppActive) {
        state.__ppActive = false;
        render();
      } else {
        renderBreathingOnly();
      }
    }
  }, 300);

  // Periodic weather updates (every 5 minutes)
  setInterval(()=>{
    if (state.weather.enabled) {
      fetchWeather();
    }
  }, 5 * 60 * 1000);

  initLocationAstronomy();
  if (state.weather.enabled) fetchWeather();
  render();
})();</script>
</body>
</html>